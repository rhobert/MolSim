// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "InputParameters.h"

namespace PSE_Molekulardynamik_WS12
{
  // nonEmptyString_t
  // 


  // positiveDecimal_t
  // 


  // nonNegativeDecimal_t
  // 


  // dimensionCount_t
  // 


  // positiveDecimalVector_t
  // 

  const positiveDecimalVector_t::x_type& positiveDecimalVector_t::
  x () const
  {
    return this->x_.get ();
  }

  positiveDecimalVector_t::x_type& positiveDecimalVector_t::
  x ()
  {
    return this->x_.get ();
  }

  void positiveDecimalVector_t::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  void positiveDecimalVector_t::
  x (::std::auto_ptr< x_type > x)
  {
    this->x_.set (x);
  }

  const positiveDecimalVector_t::y_type& positiveDecimalVector_t::
  y () const
  {
    return this->y_.get ();
  }

  positiveDecimalVector_t::y_type& positiveDecimalVector_t::
  y ()
  {
    return this->y_.get ();
  }

  void positiveDecimalVector_t::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  void positiveDecimalVector_t::
  y (::std::auto_ptr< y_type > x)
  {
    this->y_.set (x);
  }

  const positiveDecimalVector_t::z_type& positiveDecimalVector_t::
  z () const
  {
    return this->z_.get ();
  }

  positiveDecimalVector_t::z_type& positiveDecimalVector_t::
  z ()
  {
    return this->z_.get ();
  }

  void positiveDecimalVector_t::
  z (const z_type& x)
  {
    this->z_.set (x);
  }

  void positiveDecimalVector_t::
  z (::std::auto_ptr< z_type > x)
  {
    this->z_.set (x);
  }


  // decimalVector_t
  // 

  const decimalVector_t::x_type& decimalVector_t::
  x () const
  {
    return this->x_.get ();
  }

  decimalVector_t::x_type& decimalVector_t::
  x ()
  {
    return this->x_.get ();
  }

  void decimalVector_t::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const decimalVector_t::y_type& decimalVector_t::
  y () const
  {
    return this->y_.get ();
  }

  decimalVector_t::y_type& decimalVector_t::
  y ()
  {
    return this->y_.get ();
  }

  void decimalVector_t::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  const decimalVector_t::z_type& decimalVector_t::
  z () const
  {
    return this->z_.get ();
  }

  decimalVector_t::z_type& decimalVector_t::
  z ()
  {
    return this->z_.get ();
  }

  void decimalVector_t::
  z (const z_type& x)
  {
    this->z_.set (x);
  }


  // positiveIntegerVector_t
  // 

  const positiveIntegerVector_t::x_type& positiveIntegerVector_t::
  x () const
  {
    return this->x_.get ();
  }

  positiveIntegerVector_t::x_type& positiveIntegerVector_t::
  x ()
  {
    return this->x_.get ();
  }

  void positiveIntegerVector_t::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  void positiveIntegerVector_t::
  x (::std::auto_ptr< x_type > x)
  {
    this->x_.set (x);
  }

  const positiveIntegerVector_t::y_type& positiveIntegerVector_t::
  y () const
  {
    return this->y_.get ();
  }

  positiveIntegerVector_t::y_type& positiveIntegerVector_t::
  y ()
  {
    return this->y_.get ();
  }

  void positiveIntegerVector_t::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  void positiveIntegerVector_t::
  y (::std::auto_ptr< y_type > x)
  {
    this->y_.set (x);
  }

  const positiveIntegerVector_t::z_type& positiveIntegerVector_t::
  z () const
  {
    return this->z_.get ();
  }

  positiveIntegerVector_t::z_type& positiveIntegerVector_t::
  z ()
  {
    return this->z_.get ();
  }

  void positiveIntegerVector_t::
  z (const z_type& x)
  {
    this->z_.set (x);
  }

  void positiveIntegerVector_t::
  z (::std::auto_ptr< z_type > x)
  {
    this->z_.set (x);
  }


  // nonNegativeIntegerVector_t
  // 

  const nonNegativeIntegerVector_t::x_type& nonNegativeIntegerVector_t::
  x () const
  {
    return this->x_.get ();
  }

  nonNegativeIntegerVector_t::x_type& nonNegativeIntegerVector_t::
  x ()
  {
    return this->x_.get ();
  }

  void nonNegativeIntegerVector_t::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  void nonNegativeIntegerVector_t::
  x (::std::auto_ptr< x_type > x)
  {
    this->x_.set (x);
  }

  const nonNegativeIntegerVector_t::y_type& nonNegativeIntegerVector_t::
  y () const
  {
    return this->y_.get ();
  }

  nonNegativeIntegerVector_t::y_type& nonNegativeIntegerVector_t::
  y ()
  {
    return this->y_.get ();
  }

  void nonNegativeIntegerVector_t::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  void nonNegativeIntegerVector_t::
  y (::std::auto_ptr< y_type > x)
  {
    this->y_.set (x);
  }

  const nonNegativeIntegerVector_t::z_type& nonNegativeIntegerVector_t::
  z () const
  {
    return this->z_.get ();
  }

  nonNegativeIntegerVector_t::z_type& nonNegativeIntegerVector_t::
  z ()
  {
    return this->z_.get ();
  }

  void nonNegativeIntegerVector_t::
  z (const z_type& x)
  {
    this->z_.set (x);
  }

  void nonNegativeIntegerVector_t::
  z (::std::auto_ptr< z_type > x)
  {
    this->z_.set (x);
  }


  // nonNegativeIntegerVectorList_t
  // 

  const nonNegativeIntegerVectorList_t::position_sequence& nonNegativeIntegerVectorList_t::
  position () const
  {
    return this->position_;
  }

  nonNegativeIntegerVectorList_t::position_sequence& nonNegativeIntegerVectorList_t::
  position ()
  {
    return this->position_;
  }

  void nonNegativeIntegerVectorList_t::
  position (const position_sequence& s)
  {
    this->position_ = s;
  }


  // dimensionBoundaries_t
  // 

  const dimensionBoundaries_t::lower_type& dimensionBoundaries_t::
  lower () const
  {
    return this->lower_.get ();
  }

  dimensionBoundaries_t::lower_type& dimensionBoundaries_t::
  lower ()
  {
    return this->lower_.get ();
  }

  void dimensionBoundaries_t::
  lower (const lower_type& x)
  {
    this->lower_.set (x);
  }

  void dimensionBoundaries_t::
  lower (::std::auto_ptr< lower_type > x)
  {
    this->lower_.set (x);
  }

  const dimensionBoundaries_t::upper_type& dimensionBoundaries_t::
  upper () const
  {
    return this->upper_.get ();
  }

  dimensionBoundaries_t::upper_type& dimensionBoundaries_t::
  upper ()
  {
    return this->upper_.get ();
  }

  void dimensionBoundaries_t::
  upper (const upper_type& x)
  {
    this->upper_.set (x);
  }

  void dimensionBoundaries_t::
  upper (::std::auto_ptr< upper_type > x)
  {
    this->upper_.set (x);
  }


  // output_t
  // 

  const output_t::file_type& output_t::
  file () const
  {
    return this->file_.get ();
  }

  output_t::file_type& output_t::
  file ()
  {
    return this->file_.get ();
  }

  void output_t::
  file (const file_type& x)
  {
    this->file_.set (x);
  }

  void output_t::
  file (::std::auto_ptr< file_type > x)
  {
    this->file_.set (x);
  }

  const output_t::writeFrequency_type& output_t::
  writeFrequency () const
  {
    return this->writeFrequency_.get ();
  }

  output_t::writeFrequency_type& output_t::
  writeFrequency ()
  {
    return this->writeFrequency_.get ();
  }

  void output_t::
  writeFrequency (const writeFrequency_type& x)
  {
    this->writeFrequency_.set (x);
  }


  // inputType_t
  // 

  inputType_t::
  inputType_t (value v)
  : ::xml_schema::string (_xsd_inputType_t_literals_[v])
  {
  }

  inputType_t::
  inputType_t (const char* v)
  : ::xml_schema::string (v)
  {
  }

  inputType_t::
  inputType_t (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  inputType_t::
  inputType_t (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  inputType_t::
  inputType_t (const inputType_t& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  inputType_t& inputType_t::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_inputType_t_literals_[v]);

    return *this;
  }


  // inputFile_t
  // 

  const inputFile_t::type_type& inputFile_t::
  type () const
  {
    return this->type_.get ();
  }

  inputFile_t::type_type& inputFile_t::
  type ()
  {
    return this->type_.get ();
  }

  void inputFile_t::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void inputFile_t::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // staticForce_t
  // 

  const staticForce_t::F_type& staticForce_t::
  F () const
  {
    return this->F_.get ();
  }

  staticForce_t::F_type& staticForce_t::
  F ()
  {
    return this->F_.get ();
  }

  void staticForce_t::
  F (const F_type& x)
  {
    this->F_.set (x);
  }

  void staticForce_t::
  F (::std::auto_ptr< F_type > x)
  {
    this->F_.set (x);
  }

  const staticForce_t::positions_type& staticForce_t::
  positions () const
  {
    return this->positions_.get ();
  }

  staticForce_t::positions_type& staticForce_t::
  positions ()
  {
    return this->positions_.get ();
  }

  void staticForce_t::
  positions (const positions_type& x)
  {
    this->positions_.set (x);
  }

  void staticForce_t::
  positions (::std::auto_ptr< positions_type > x)
  {
    this->positions_.set (x);
  }

  const staticForce_t::timeEffective_optional& staticForce_t::
  timeEffective () const
  {
    return this->timeEffective_;
  }

  staticForce_t::timeEffective_optional& staticForce_t::
  timeEffective ()
  {
    return this->timeEffective_;
  }

  void staticForce_t::
  timeEffective (const timeEffective_type& x)
  {
    this->timeEffective_.set (x);
  }

  void staticForce_t::
  timeEffective (const timeEffective_optional& x)
  {
    this->timeEffective_ = x;
  }

  void staticForce_t::
  timeEffective (::std::auto_ptr< timeEffective_type > x)
  {
    this->timeEffective_.set (x);
  }


  // membrane_t
  // 

  const membrane_t::stiffnessConstant_type& membrane_t::
  stiffnessConstant () const
  {
    return this->stiffnessConstant_.get ();
  }

  membrane_t::stiffnessConstant_type& membrane_t::
  stiffnessConstant ()
  {
    return this->stiffnessConstant_.get ();
  }

  void membrane_t::
  stiffnessConstant (const stiffnessConstant_type& x)
  {
    this->stiffnessConstant_.set (x);
  }

  void membrane_t::
  stiffnessConstant (::std::auto_ptr< stiffnessConstant_type > x)
  {
    this->stiffnessConstant_.set (x);
  }

  const membrane_t::averageBondLength_type& membrane_t::
  averageBondLength () const
  {
    return this->averageBondLength_.get ();
  }

  membrane_t::averageBondLength_type& membrane_t::
  averageBondLength ()
  {
    return this->averageBondLength_.get ();
  }

  void membrane_t::
  averageBondLength (const averageBondLength_type& x)
  {
    this->averageBondLength_.set (x);
  }

  void membrane_t::
  averageBondLength (::std::auto_ptr< averageBondLength_type > x)
  {
    this->averageBondLength_.set (x);
  }

  const membrane_t::staticForce_optional& membrane_t::
  staticForce () const
  {
    return this->staticForce_;
  }

  membrane_t::staticForce_optional& membrane_t::
  staticForce ()
  {
    return this->staticForce_;
  }

  void membrane_t::
  staticForce (const staticForce_type& x)
  {
    this->staticForce_.set (x);
  }

  void membrane_t::
  staticForce (const staticForce_optional& x)
  {
    this->staticForce_ = x;
  }

  void membrane_t::
  staticForce (::std::auto_ptr< staticForce_type > x)
  {
    this->staticForce_.set (x);
  }


  // cuboid_t
  // 

  const cuboid_t::position_type& cuboid_t::
  position () const
  {
    return this->position_.get ();
  }

  cuboid_t::position_type& cuboid_t::
  position ()
  {
    return this->position_.get ();
  }

  void cuboid_t::
  position (const position_type& x)
  {
    this->position_.set (x);
  }

  void cuboid_t::
  position (::std::auto_ptr< position_type > x)
  {
    this->position_.set (x);
  }

  const cuboid_t::velocity_type& cuboid_t::
  velocity () const
  {
    return this->velocity_.get ();
  }

  cuboid_t::velocity_type& cuboid_t::
  velocity ()
  {
    return this->velocity_.get ();
  }

  void cuboid_t::
  velocity (const velocity_type& x)
  {
    this->velocity_.set (x);
  }

  void cuboid_t::
  velocity (::std::auto_ptr< velocity_type > x)
  {
    this->velocity_.set (x);
  }

  const cuboid_t::dimensions_type& cuboid_t::
  dimensions () const
  {
    return this->dimensions_.get ();
  }

  cuboid_t::dimensions_type& cuboid_t::
  dimensions ()
  {
    return this->dimensions_.get ();
  }

  void cuboid_t::
  dimensions (const dimensions_type& x)
  {
    this->dimensions_.set (x);
  }

  void cuboid_t::
  dimensions (::std::auto_ptr< dimensions_type > x)
  {
    this->dimensions_.set (x);
  }

  const cuboid_t::mass_type& cuboid_t::
  mass () const
  {
    return this->mass_.get ();
  }

  cuboid_t::mass_type& cuboid_t::
  mass ()
  {
    return this->mass_.get ();
  }

  void cuboid_t::
  mass (const mass_type& x)
  {
    this->mass_.set (x);
  }

  void cuboid_t::
  mass (::std::auto_ptr< mass_type > x)
  {
    this->mass_.set (x);
  }

  const cuboid_t::distance_type& cuboid_t::
  distance () const
  {
    return this->distance_.get ();
  }

  cuboid_t::distance_type& cuboid_t::
  distance ()
  {
    return this->distance_.get ();
  }

  void cuboid_t::
  distance (const distance_type& x)
  {
    this->distance_.set (x);
  }

  void cuboid_t::
  distance (::std::auto_ptr< distance_type > x)
  {
    this->distance_.set (x);
  }

  const cuboid_t::sigma_type& cuboid_t::
  sigma () const
  {
    return this->sigma_.get ();
  }

  cuboid_t::sigma_type& cuboid_t::
  sigma ()
  {
    return this->sigma_.get ();
  }

  void cuboid_t::
  sigma (const sigma_type& x)
  {
    this->sigma_.set (x);
  }

  const cuboid_t::epsilon_type& cuboid_t::
  epsilon () const
  {
    return this->epsilon_.get ();
  }

  cuboid_t::epsilon_type& cuboid_t::
  epsilon ()
  {
    return this->epsilon_.get ();
  }

  void cuboid_t::
  epsilon (const epsilon_type& x)
  {
    this->epsilon_.set (x);
  }

  const cuboid_t::type_type& cuboid_t::
  type () const
  {
    return this->type_.get ();
  }

  cuboid_t::type_type& cuboid_t::
  type ()
  {
    return this->type_.get ();
  }

  void cuboid_t::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  const cuboid_t::membrane_optional& cuboid_t::
  membrane () const
  {
    return this->membrane_;
  }

  cuboid_t::membrane_optional& cuboid_t::
  membrane ()
  {
    return this->membrane_;
  }

  void cuboid_t::
  membrane (const membrane_type& x)
  {
    this->membrane_.set (x);
  }

  void cuboid_t::
  membrane (const membrane_optional& x)
  {
    this->membrane_ = x;
  }

  void cuboid_t::
  membrane (::std::auto_ptr< membrane_type > x)
  {
    this->membrane_.set (x);
  }


  // sphere_t
  // 

  const sphere_t::position_type& sphere_t::
  position () const
  {
    return this->position_.get ();
  }

  sphere_t::position_type& sphere_t::
  position ()
  {
    return this->position_.get ();
  }

  void sphere_t::
  position (const position_type& x)
  {
    this->position_.set (x);
  }

  void sphere_t::
  position (::std::auto_ptr< position_type > x)
  {
    this->position_.set (x);
  }

  const sphere_t::velocity_type& sphere_t::
  velocity () const
  {
    return this->velocity_.get ();
  }

  sphere_t::velocity_type& sphere_t::
  velocity ()
  {
    return this->velocity_.get ();
  }

  void sphere_t::
  velocity (const velocity_type& x)
  {
    this->velocity_.set (x);
  }

  void sphere_t::
  velocity (::std::auto_ptr< velocity_type > x)
  {
    this->velocity_.set (x);
  }

  const sphere_t::radiusDimension_type& sphere_t::
  radiusDimension () const
  {
    return this->radiusDimension_.get ();
  }

  sphere_t::radiusDimension_type& sphere_t::
  radiusDimension ()
  {
    return this->radiusDimension_.get ();
  }

  void sphere_t::
  radiusDimension (const radiusDimension_type& x)
  {
    this->radiusDimension_.set (x);
  }

  const sphere_t::mass_type& sphere_t::
  mass () const
  {
    return this->mass_.get ();
  }

  sphere_t::mass_type& sphere_t::
  mass ()
  {
    return this->mass_.get ();
  }

  void sphere_t::
  mass (const mass_type& x)
  {
    this->mass_.set (x);
  }

  void sphere_t::
  mass (::std::auto_ptr< mass_type > x)
  {
    this->mass_.set (x);
  }

  const sphere_t::distance_type& sphere_t::
  distance () const
  {
    return this->distance_.get ();
  }

  sphere_t::distance_type& sphere_t::
  distance ()
  {
    return this->distance_.get ();
  }

  void sphere_t::
  distance (const distance_type& x)
  {
    this->distance_.set (x);
  }

  void sphere_t::
  distance (::std::auto_ptr< distance_type > x)
  {
    this->distance_.set (x);
  }

  const sphere_t::sigma_type& sphere_t::
  sigma () const
  {
    return this->sigma_.get ();
  }

  sphere_t::sigma_type& sphere_t::
  sigma ()
  {
    return this->sigma_.get ();
  }

  void sphere_t::
  sigma (const sigma_type& x)
  {
    this->sigma_.set (x);
  }

  const sphere_t::epsilon_type& sphere_t::
  epsilon () const
  {
    return this->epsilon_.get ();
  }

  sphere_t::epsilon_type& sphere_t::
  epsilon ()
  {
    return this->epsilon_.get ();
  }

  void sphere_t::
  epsilon (const epsilon_type& x)
  {
    this->epsilon_.set (x);
  }

  const sphere_t::type_type& sphere_t::
  type () const
  {
    return this->type_.get ();
  }

  sphere_t::type_type& sphere_t::
  type ()
  {
    return this->type_.get ();
  }

  void sphere_t::
  type (const type_type& x)
  {
    this->type_.set (x);
  }


  // inputs_t
  // 

  const inputs_t::inputFile_sequence& inputs_t::
  inputFile () const
  {
    return this->inputFile_;
  }

  inputs_t::inputFile_sequence& inputs_t::
  inputFile ()
  {
    return this->inputFile_;
  }

  void inputs_t::
  inputFile (const inputFile_sequence& s)
  {
    this->inputFile_ = s;
  }

  const inputs_t::cuboid_sequence& inputs_t::
  cuboid () const
  {
    return this->cuboid_;
  }

  inputs_t::cuboid_sequence& inputs_t::
  cuboid ()
  {
    return this->cuboid_;
  }

  void inputs_t::
  cuboid (const cuboid_sequence& s)
  {
    this->cuboid_ = s;
  }

  const inputs_t::sphere_sequence& inputs_t::
  sphere () const
  {
    return this->sphere_;
  }

  inputs_t::sphere_sequence& inputs_t::
  sphere ()
  {
    return this->sphere_;
  }

  void inputs_t::
  sphere (const sphere_sequence& s)
  {
    this->sphere_ = s;
  }


  // smoothedLennardJones_t
  // 

  const smoothedLennardJones_t::rl_type& smoothedLennardJones_t::
  rl () const
  {
    return this->rl_.get ();
  }

  smoothedLennardJones_t::rl_type& smoothedLennardJones_t::
  rl ()
  {
    return this->rl_.get ();
  }

  void smoothedLennardJones_t::
  rl (const rl_type& x)
  {
    this->rl_.set (x);
  }

  void smoothedLennardJones_t::
  rl (::std::auto_ptr< rl_type > x)
  {
    this->rl_.set (x);
  }


  // potential_t
  // 

  const potential_t::gravitational_optional& potential_t::
  gravitational () const
  {
    return this->gravitational_;
  }

  potential_t::gravitational_optional& potential_t::
  gravitational ()
  {
    return this->gravitational_;
  }

  void potential_t::
  gravitational (const gravitational_type& x)
  {
    this->gravitational_.set (x);
  }

  void potential_t::
  gravitational (const gravitational_optional& x)
  {
    this->gravitational_ = x;
  }

  void potential_t::
  gravitational (::std::auto_ptr< gravitational_type > x)
  {
    this->gravitational_.set (x);
  }

  const potential_t::lennardJones_optional& potential_t::
  lennardJones () const
  {
    return this->lennardJones_;
  }

  potential_t::lennardJones_optional& potential_t::
  lennardJones ()
  {
    return this->lennardJones_;
  }

  void potential_t::
  lennardJones (const lennardJones_type& x)
  {
    this->lennardJones_.set (x);
  }

  void potential_t::
  lennardJones (const lennardJones_optional& x)
  {
    this->lennardJones_ = x;
  }

  void potential_t::
  lennardJones (::std::auto_ptr< lennardJones_type > x)
  {
    this->lennardJones_.set (x);
  }

  const potential_t::smoothedLennardJones_optional& potential_t::
  smoothedLennardJones () const
  {
    return this->smoothedLennardJones_;
  }

  potential_t::smoothedLennardJones_optional& potential_t::
  smoothedLennardJones ()
  {
    return this->smoothedLennardJones_;
  }

  void potential_t::
  smoothedLennardJones (const smoothedLennardJones_type& x)
  {
    this->smoothedLennardJones_.set (x);
  }

  void potential_t::
  smoothedLennardJones (const smoothedLennardJones_optional& x)
  {
    this->smoothedLennardJones_ = x;
  }

  void potential_t::
  smoothedLennardJones (::std::auto_ptr< smoothedLennardJones_type > x)
  {
    this->smoothedLennardJones_.set (x);
  }


  // boundary_t
  // 

  boundary_t::
  boundary_t (value v)
  : ::xml_schema::string (_xsd_boundary_t_literals_[v])
  {
  }

  boundary_t::
  boundary_t (const char* v)
  : ::xml_schema::string (v)
  {
  }

  boundary_t::
  boundary_t (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  boundary_t::
  boundary_t (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  boundary_t::
  boundary_t (const boundary_t& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  boundary_t& boundary_t::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_boundary_t_literals_[v]);

    return *this;
  }


  // domain_t
  // 

  const domain_t::dimensions_type& domain_t::
  dimensions () const
  {
    return this->dimensions_.get ();
  }

  domain_t::dimensions_type& domain_t::
  dimensions ()
  {
    return this->dimensions_.get ();
  }

  void domain_t::
  dimensions (const dimensions_type& x)
  {
    this->dimensions_.set (x);
  }

  void domain_t::
  dimensions (::std::auto_ptr< dimensions_type > x)
  {
    this->dimensions_.set (x);
  }

  const domain_t::cutoff_type& domain_t::
  cutoff () const
  {
    return this->cutoff_.get ();
  }

  domain_t::cutoff_type& domain_t::
  cutoff ()
  {
    return this->cutoff_.get ();
  }

  void domain_t::
  cutoff (const cutoff_type& x)
  {
    this->cutoff_.set (x);
  }

  void domain_t::
  cutoff (::std::auto_ptr< cutoff_type > x)
  {
    this->cutoff_.set (x);
  }

  const domain_t::x_type& domain_t::
  x () const
  {
    return this->x_.get ();
  }

  domain_t::x_type& domain_t::
  x ()
  {
    return this->x_.get ();
  }

  void domain_t::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  void domain_t::
  x (::std::auto_ptr< x_type > x)
  {
    this->x_.set (x);
  }

  const domain_t::y_optional& domain_t::
  y () const
  {
    return this->y_;
  }

  domain_t::y_optional& domain_t::
  y ()
  {
    return this->y_;
  }

  void domain_t::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  void domain_t::
  y (const y_optional& x)
  {
    this->y_ = x;
  }

  void domain_t::
  y (::std::auto_ptr< y_type > x)
  {
    this->y_.set (x);
  }

  const domain_t::z_optional& domain_t::
  z () const
  {
    return this->z_;
  }

  domain_t::z_optional& domain_t::
  z ()
  {
    return this->z_;
  }

  void domain_t::
  z (const z_type& x)
  {
    this->z_.set (x);
  }

  void domain_t::
  z (const z_optional& x)
  {
    this->z_ = x;
  }

  void domain_t::
  z (::std::auto_ptr< z_type > x)
  {
    this->z_.set (x);
  }


  // thermostat_t
  // 

  const thermostat_t::initialT_type& thermostat_t::
  initialT () const
  {
    return this->initialT_.get ();
  }

  thermostat_t::initialT_type& thermostat_t::
  initialT ()
  {
    return this->initialT_.get ();
  }

  void thermostat_t::
  initialT (const initialT_type& x)
  {
    this->initialT_.set (x);
  }

  void thermostat_t::
  initialT (::std::auto_ptr< initialT_type > x)
  {
    this->initialT_.set (x);
  }

  const thermostat_t::frequency_optional& thermostat_t::
  frequency () const
  {
    return this->frequency_;
  }

  thermostat_t::frequency_optional& thermostat_t::
  frequency ()
  {
    return this->frequency_;
  }

  void thermostat_t::
  frequency (const frequency_type& x)
  {
    this->frequency_.set (x);
  }

  void thermostat_t::
  frequency (const frequency_optional& x)
  {
    this->frequency_ = x;
  }


  // simulation_t
  // 

  const simulation_t::output_optional& simulation_t::
  output () const
  {
    return this->output_;
  }

  simulation_t::output_optional& simulation_t::
  output ()
  {
    return this->output_;
  }

  void simulation_t::
  output (const output_type& x)
  {
    this->output_.set (x);
  }

  void simulation_t::
  output (const output_optional& x)
  {
    this->output_ = x;
  }

  void simulation_t::
  output (::std::auto_ptr< output_type > x)
  {
    this->output_.set (x);
  }

  const simulation_t::outputPhaseSpace_optional& simulation_t::
  outputPhaseSpace () const
  {
    return this->outputPhaseSpace_;
  }

  simulation_t::outputPhaseSpace_optional& simulation_t::
  outputPhaseSpace ()
  {
    return this->outputPhaseSpace_;
  }

  void simulation_t::
  outputPhaseSpace (const outputPhaseSpace_type& x)
  {
    this->outputPhaseSpace_.set (x);
  }

  void simulation_t::
  outputPhaseSpace (const outputPhaseSpace_optional& x)
  {
    this->outputPhaseSpace_ = x;
  }

  void simulation_t::
  outputPhaseSpace (::std::auto_ptr< outputPhaseSpace_type > x)
  {
    this->outputPhaseSpace_.set (x);
  }

  const simulation_t::inputs_type& simulation_t::
  inputs () const
  {
    return this->inputs_.get ();
  }

  simulation_t::inputs_type& simulation_t::
  inputs ()
  {
    return this->inputs_.get ();
  }

  void simulation_t::
  inputs (const inputs_type& x)
  {
    this->inputs_.set (x);
  }

  void simulation_t::
  inputs (::std::auto_ptr< inputs_type > x)
  {
    this->inputs_.set (x);
  }

  const simulation_t::t_end_type& simulation_t::
  t_end () const
  {
    return this->t_end_.get ();
  }

  simulation_t::t_end_type& simulation_t::
  t_end ()
  {
    return this->t_end_.get ();
  }

  void simulation_t::
  t_end (const t_end_type& x)
  {
    this->t_end_.set (x);
  }

  void simulation_t::
  t_end (::std::auto_ptr< t_end_type > x)
  {
    this->t_end_.set (x);
  }

  const simulation_t::delta_t_type& simulation_t::
  delta_t () const
  {
    return this->delta_t_.get ();
  }

  simulation_t::delta_t_type& simulation_t::
  delta_t ()
  {
    return this->delta_t_.get ();
  }

  void simulation_t::
  delta_t (const delta_t_type& x)
  {
    this->delta_t_.set (x);
  }

  void simulation_t::
  delta_t (::std::auto_ptr< delta_t_type > x)
  {
    this->delta_t_.set (x);
  }

  const simulation_t::potential_type& simulation_t::
  potential () const
  {
    return this->potential_.get ();
  }

  simulation_t::potential_type& simulation_t::
  potential ()
  {
    return this->potential_.get ();
  }

  void simulation_t::
  potential (const potential_type& x)
  {
    this->potential_.set (x);
  }

  void simulation_t::
  potential (::std::auto_ptr< potential_type > x)
  {
    this->potential_.set (x);
  }

  const simulation_t::domain_optional& simulation_t::
  domain () const
  {
    return this->domain_;
  }

  simulation_t::domain_optional& simulation_t::
  domain ()
  {
    return this->domain_;
  }

  void simulation_t::
  domain (const domain_type& x)
  {
    this->domain_.set (x);
  }

  void simulation_t::
  domain (const domain_optional& x)
  {
    this->domain_ = x;
  }

  void simulation_t::
  domain (::std::auto_ptr< domain_type > x)
  {
    this->domain_.set (x);
  }

  const simulation_t::thermostat_optional& simulation_t::
  thermostat () const
  {
    return this->thermostat_;
  }

  simulation_t::thermostat_optional& simulation_t::
  thermostat ()
  {
    return this->thermostat_;
  }

  void simulation_t::
  thermostat (const thermostat_type& x)
  {
    this->thermostat_.set (x);
  }

  void simulation_t::
  thermostat (const thermostat_optional& x)
  {
    this->thermostat_ = x;
  }

  void simulation_t::
  thermostat (::std::auto_ptr< thermostat_type > x)
  {
    this->thermostat_.set (x);
  }

  const simulation_t::dimensionCount_type& simulation_t::
  dimensionCount () const
  {
    return this->dimensionCount_.get ();
  }

  simulation_t::dimensionCount_type& simulation_t::
  dimensionCount ()
  {
    return this->dimensionCount_.get ();
  }

  void simulation_t::
  dimensionCount (const dimensionCount_type& x)
  {
    this->dimensionCount_.set (x);
  }

  void simulation_t::
  dimensionCount (::std::auto_ptr< dimensionCount_type > x)
  {
    this->dimensionCount_.set (x);
  }

  const simulation_t::gravitation_optional& simulation_t::
  gravitation () const
  {
    return this->gravitation_;
  }

  simulation_t::gravitation_optional& simulation_t::
  gravitation ()
  {
    return this->gravitation_;
  }

  void simulation_t::
  gravitation (const gravitation_type& x)
  {
    this->gravitation_.set (x);
  }

  void simulation_t::
  gravitation (const gravitation_optional& x)
  {
    this->gravitation_ = x;
  }

  void simulation_t::
  gravitation (::std::auto_ptr< gravitation_type > x)
  {
    this->gravitation_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace PSE_Molekulardynamik_WS12
{
  // nonEmptyString_t
  //

  nonEmptyString_t::
  nonEmptyString_t ()
  : ::xml_schema::string ()
  {
  }

  nonEmptyString_t::
  nonEmptyString_t (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  nonEmptyString_t::
  nonEmptyString_t (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  nonEmptyString_t::
  nonEmptyString_t (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  nonEmptyString_t::
  nonEmptyString_t (const nonEmptyString_t& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  nonEmptyString_t::
  nonEmptyString_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  nonEmptyString_t::
  nonEmptyString_t (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  nonEmptyString_t::
  nonEmptyString_t (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  nonEmptyString_t* nonEmptyString_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class nonEmptyString_t (*this, f, c);
  }

  nonEmptyString_t::
  ~nonEmptyString_t ()
  {
  }

  // positiveDecimal_t
  //

  positiveDecimal_t::
  positiveDecimal_t (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  positiveDecimal_t::
  positiveDecimal_t (const positiveDecimal_t& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  positiveDecimal_t::
  positiveDecimal_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  positiveDecimal_t::
  positiveDecimal_t (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  positiveDecimal_t::
  positiveDecimal_t (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  positiveDecimal_t* positiveDecimal_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class positiveDecimal_t (*this, f, c);
  }

  positiveDecimal_t::
  ~positiveDecimal_t ()
  {
  }

  // nonNegativeDecimal_t
  //

  nonNegativeDecimal_t::
  nonNegativeDecimal_t (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  nonNegativeDecimal_t::
  nonNegativeDecimal_t (const nonNegativeDecimal_t& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  nonNegativeDecimal_t::
  nonNegativeDecimal_t (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  nonNegativeDecimal_t::
  nonNegativeDecimal_t (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  nonNegativeDecimal_t::
  nonNegativeDecimal_t (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  nonNegativeDecimal_t* nonNegativeDecimal_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class nonNegativeDecimal_t (*this, f, c);
  }

  nonNegativeDecimal_t::
  ~nonNegativeDecimal_t ()
  {
  }

  // dimensionCount_t
  //

  dimensionCount_t::
  dimensionCount_t (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  dimensionCount_t::
  dimensionCount_t (const dimensionCount_t& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  dimensionCount_t::
  dimensionCount_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  dimensionCount_t::
  dimensionCount_t (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  dimensionCount_t::
  dimensionCount_t (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  dimensionCount_t* dimensionCount_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dimensionCount_t (*this, f, c);
  }

  dimensionCount_t::
  ~dimensionCount_t ()
  {
  }

  // positiveDecimalVector_t
  //

  positiveDecimalVector_t::
  positiveDecimalVector_t (const x_type& x,
                           const y_type& y,
                           const z_type& z)
  : ::xml_schema::type (),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    z_ (z, ::xml_schema::flags (), this)
  {
  }

  positiveDecimalVector_t::
  positiveDecimalVector_t (const positiveDecimalVector_t& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  positiveDecimalVector_t::
  positiveDecimalVector_t (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (f, this),
    y_ (f, this),
    z_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void positiveDecimalVector_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< y_type > r (
          y_traits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< z_type > r (
          z_traits::create (i, f, this));

        if (!z_.present ())
        {
          this->z_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "z",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  positiveDecimalVector_t* positiveDecimalVector_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class positiveDecimalVector_t (*this, f, c);
  }

  positiveDecimalVector_t::
  ~positiveDecimalVector_t ()
  {
  }

  // decimalVector_t
  //

  decimalVector_t::
  decimalVector_t (const x_type& x,
                   const y_type& y,
                   const z_type& z)
  : ::xml_schema::type (),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    z_ (z, ::xml_schema::flags (), this)
  {
  }

  decimalVector_t::
  decimalVector_t (const decimalVector_t& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  decimalVector_t::
  decimalVector_t (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (f, this),
    y_ (f, this),
    z_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void decimalVector_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!z_.present ())
        {
          this->z_.set (z_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "z",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  decimalVector_t* decimalVector_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class decimalVector_t (*this, f, c);
  }

  decimalVector_t::
  ~decimalVector_t ()
  {
  }

  // positiveIntegerVector_t
  //

  positiveIntegerVector_t::
  positiveIntegerVector_t (const x_type& x,
                           const y_type& y,
                           const z_type& z)
  : ::xml_schema::type (),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    z_ (z, ::xml_schema::flags (), this)
  {
  }

  positiveIntegerVector_t::
  positiveIntegerVector_t (const positiveIntegerVector_t& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  positiveIntegerVector_t::
  positiveIntegerVector_t (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (f, this),
    y_ (f, this),
    z_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void positiveIntegerVector_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< y_type > r (
          y_traits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< z_type > r (
          z_traits::create (i, f, this));

        if (!z_.present ())
        {
          this->z_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "z",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  positiveIntegerVector_t* positiveIntegerVector_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class positiveIntegerVector_t (*this, f, c);
  }

  positiveIntegerVector_t::
  ~positiveIntegerVector_t ()
  {
  }

  // nonNegativeIntegerVector_t
  //

  nonNegativeIntegerVector_t::
  nonNegativeIntegerVector_t (const x_type& x,
                              const y_type& y,
                              const z_type& z)
  : ::xml_schema::type (),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    z_ (z, ::xml_schema::flags (), this)
  {
  }

  nonNegativeIntegerVector_t::
  nonNegativeIntegerVector_t (const nonNegativeIntegerVector_t& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  nonNegativeIntegerVector_t::
  nonNegativeIntegerVector_t (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (f, this),
    y_ (f, this),
    z_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void nonNegativeIntegerVector_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< y_type > r (
          y_traits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< z_type > r (
          z_traits::create (i, f, this));

        if (!z_.present ())
        {
          this->z_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "z",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  nonNegativeIntegerVector_t* nonNegativeIntegerVector_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class nonNegativeIntegerVector_t (*this, f, c);
  }

  nonNegativeIntegerVector_t::
  ~nonNegativeIntegerVector_t ()
  {
  }

  // nonNegativeIntegerVectorList_t
  //

  nonNegativeIntegerVectorList_t::
  nonNegativeIntegerVectorList_t ()
  : ::xml_schema::type (),
    position_ (::xml_schema::flags (), this)
  {
  }

  nonNegativeIntegerVectorList_t::
  nonNegativeIntegerVectorList_t (const nonNegativeIntegerVectorList_t& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    position_ (x.position_, f, this)
  {
  }

  nonNegativeIntegerVectorList_t::
  nonNegativeIntegerVectorList_t (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    position_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void nonNegativeIntegerVectorList_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // position
      //
      if (n.name () == "position" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< position_type > r (
          position_traits::create (i, f, this));

        this->position_.push_back (r);
        continue;
      }

      break;
    }
  }

  nonNegativeIntegerVectorList_t* nonNegativeIntegerVectorList_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class nonNegativeIntegerVectorList_t (*this, f, c);
  }

  nonNegativeIntegerVectorList_t::
  ~nonNegativeIntegerVectorList_t ()
  {
  }

  // dimensionBoundaries_t
  //

  dimensionBoundaries_t::
  dimensionBoundaries_t (const lower_type& lower,
                         const upper_type& upper)
  : ::xml_schema::type (),
    lower_ (lower, ::xml_schema::flags (), this),
    upper_ (upper, ::xml_schema::flags (), this)
  {
  }

  dimensionBoundaries_t::
  dimensionBoundaries_t (const dimensionBoundaries_t& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    lower_ (x.lower_, f, this),
    upper_ (x.upper_, f, this)
  {
  }

  dimensionBoundaries_t::
  dimensionBoundaries_t (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    lower_ (f, this),
    upper_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void dimensionBoundaries_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lower
      //
      if (n.name () == "lower" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< lower_type > r (
          lower_traits::create (i, f, this));

        if (!lower_.present ())
        {
          this->lower_.set (r);
          continue;
        }
      }

      // upper
      //
      if (n.name () == "upper" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< upper_type > r (
          upper_traits::create (i, f, this));

        if (!upper_.present ())
        {
          this->upper_.set (r);
          continue;
        }
      }

      break;
    }

    if (!lower_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "lower",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!upper_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "upper",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  dimensionBoundaries_t* dimensionBoundaries_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dimensionBoundaries_t (*this, f, c);
  }

  dimensionBoundaries_t::
  ~dimensionBoundaries_t ()
  {
  }

  // output_t
  //

  output_t::
  output_t (const file_type& file,
            const writeFrequency_type& writeFrequency)
  : ::xml_schema::type (),
    file_ (file, ::xml_schema::flags (), this),
    writeFrequency_ (writeFrequency, ::xml_schema::flags (), this)
  {
  }

  output_t::
  output_t (const output_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    file_ (x.file_, f, this),
    writeFrequency_ (x.writeFrequency_, f, this)
  {
  }

  output_t::
  output_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    file_ (f, this),
    writeFrequency_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void output_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // file
      //
      if (n.name () == "file" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< file_type > r (
          file_traits::create (i, f, this));

        if (!file_.present ())
        {
          this->file_.set (r);
          continue;
        }
      }

      // writeFrequency
      //
      if (n.name () == "writeFrequency" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!writeFrequency_.present ())
        {
          this->writeFrequency_.set (writeFrequency_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!file_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "file",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!writeFrequency_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "writeFrequency",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  output_t* output_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class output_t (*this, f, c);
  }

  output_t::
  ~output_t ()
  {
  }

  // inputType_t
  //

  inputType_t::
  inputType_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_inputType_t_convert ();
  }

  inputType_t::
  inputType_t (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_inputType_t_convert ();
  }

  inputType_t::
  inputType_t (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_inputType_t_convert ();
  }

  inputType_t* inputType_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class inputType_t (*this, f, c);
  }

  inputType_t::value inputType_t::
  _xsd_inputType_t_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_inputType_t_literals_);
    const value* i (::std::lower_bound (
                      _xsd_inputType_t_indexes_,
                      _xsd_inputType_t_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_inputType_t_indexes_ + 3 || _xsd_inputType_t_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const inputType_t::
  _xsd_inputType_t_literals_[3] =
  {
    "list",
    "cuboid",
    "phaseSpace"
  };

  const inputType_t::value inputType_t::
  _xsd_inputType_t_indexes_[3] =
  {
    ::PSE_Molekulardynamik_WS12::inputType_t::cuboid,
    ::PSE_Molekulardynamik_WS12::inputType_t::list,
    ::PSE_Molekulardynamik_WS12::inputType_t::phaseSpace
  };

  // inputFile_t
  //

  inputFile_t::
  inputFile_t (const type_type& type)
  : ::PSE_Molekulardynamik_WS12::nonEmptyString_t (),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  inputFile_t::
  inputFile_t (const char* _xsd_string_base,
               const type_type& type)
  : ::PSE_Molekulardynamik_WS12::nonEmptyString_t (_xsd_string_base),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  inputFile_t::
  inputFile_t (const ::std::string& _xsd_string_base,
               const type_type& type)
  : ::PSE_Molekulardynamik_WS12::nonEmptyString_t (_xsd_string_base),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  inputFile_t::
  inputFile_t (const ::xml_schema::string& _xsd_string_base,
               const type_type& type)
  : ::PSE_Molekulardynamik_WS12::nonEmptyString_t (_xsd_string_base),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  inputFile_t::
  inputFile_t (const inputFile_t& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::PSE_Molekulardynamik_WS12::nonEmptyString_t (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  inputFile_t::
  inputFile_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::PSE_Molekulardynamik_WS12::nonEmptyString_t (e, f | ::xml_schema::flags::base, c),
    type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void inputFile_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  inputFile_t* inputFile_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class inputFile_t (*this, f, c);
  }

  inputFile_t::
  ~inputFile_t ()
  {
  }

  // staticForce_t
  //

  staticForce_t::
  staticForce_t (const F_type& F,
                 const positions_type& positions)
  : ::xml_schema::type (),
    F_ (F, ::xml_schema::flags (), this),
    positions_ (positions, ::xml_schema::flags (), this),
    timeEffective_ (::xml_schema::flags (), this)
  {
  }

  staticForce_t::
  staticForce_t (::std::auto_ptr< F_type >& F,
                 ::std::auto_ptr< positions_type >& positions)
  : ::xml_schema::type (),
    F_ (F, ::xml_schema::flags (), this),
    positions_ (positions, ::xml_schema::flags (), this),
    timeEffective_ (::xml_schema::flags (), this)
  {
  }

  staticForce_t::
  staticForce_t (const staticForce_t& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    F_ (x.F_, f, this),
    positions_ (x.positions_, f, this),
    timeEffective_ (x.timeEffective_, f, this)
  {
  }

  staticForce_t::
  staticForce_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    F_ (f, this),
    positions_ (f, this),
    timeEffective_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void staticForce_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // F
      //
      if (n.name () == "F" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< F_type > r (
          F_traits::create (i, f, this));

        if (!F_.present ())
        {
          this->F_.set (r);
          continue;
        }
      }

      // positions
      //
      if (n.name () == "positions" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< positions_type > r (
          positions_traits::create (i, f, this));

        if (!positions_.present ())
        {
          this->positions_.set (r);
          continue;
        }
      }

      // timeEffective
      //
      if (n.name () == "timeEffective" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< timeEffective_type > r (
          timeEffective_traits::create (i, f, this));

        if (!this->timeEffective_)
        {
          this->timeEffective_.set (r);
          continue;
        }
      }

      break;
    }

    if (!F_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "F",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!positions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "positions",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  staticForce_t* staticForce_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staticForce_t (*this, f, c);
  }

  staticForce_t::
  ~staticForce_t ()
  {
  }

  // membrane_t
  //

  membrane_t::
  membrane_t (const stiffnessConstant_type& stiffnessConstant,
              const averageBondLength_type& averageBondLength)
  : ::xml_schema::type (),
    stiffnessConstant_ (stiffnessConstant, ::xml_schema::flags (), this),
    averageBondLength_ (averageBondLength, ::xml_schema::flags (), this),
    staticForce_ (::xml_schema::flags (), this)
  {
  }

  membrane_t::
  membrane_t (const membrane_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    stiffnessConstant_ (x.stiffnessConstant_, f, this),
    averageBondLength_ (x.averageBondLength_, f, this),
    staticForce_ (x.staticForce_, f, this)
  {
  }

  membrane_t::
  membrane_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    stiffnessConstant_ (f, this),
    averageBondLength_ (f, this),
    staticForce_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void membrane_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // stiffnessConstant
      //
      if (n.name () == "stiffnessConstant" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< stiffnessConstant_type > r (
          stiffnessConstant_traits::create (i, f, this));

        if (!stiffnessConstant_.present ())
        {
          this->stiffnessConstant_.set (r);
          continue;
        }
      }

      // averageBondLength
      //
      if (n.name () == "averageBondLength" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< averageBondLength_type > r (
          averageBondLength_traits::create (i, f, this));

        if (!averageBondLength_.present ())
        {
          this->averageBondLength_.set (r);
          continue;
        }
      }

      // staticForce
      //
      if (n.name () == "staticForce" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< staticForce_type > r (
          staticForce_traits::create (i, f, this));

        if (!this->staticForce_)
        {
          this->staticForce_.set (r);
          continue;
        }
      }

      break;
    }

    if (!stiffnessConstant_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stiffnessConstant",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!averageBondLength_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "averageBondLength",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  membrane_t* membrane_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class membrane_t (*this, f, c);
  }

  membrane_t::
  ~membrane_t ()
  {
  }

  // cuboid_t
  //

  cuboid_t::
  cuboid_t (const position_type& position,
            const velocity_type& velocity,
            const dimensions_type& dimensions,
            const mass_type& mass,
            const distance_type& distance,
            const sigma_type& sigma,
            const epsilon_type& epsilon,
            const type_type& type)
  : ::xml_schema::type (),
    position_ (position, ::xml_schema::flags (), this),
    velocity_ (velocity, ::xml_schema::flags (), this),
    dimensions_ (dimensions, ::xml_schema::flags (), this),
    mass_ (mass, ::xml_schema::flags (), this),
    distance_ (distance, ::xml_schema::flags (), this),
    sigma_ (sigma, ::xml_schema::flags (), this),
    epsilon_ (epsilon, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    membrane_ (::xml_schema::flags (), this)
  {
  }

  cuboid_t::
  cuboid_t (::std::auto_ptr< position_type >& position,
            ::std::auto_ptr< velocity_type >& velocity,
            ::std::auto_ptr< dimensions_type >& dimensions,
            const mass_type& mass,
            const distance_type& distance,
            const sigma_type& sigma,
            const epsilon_type& epsilon,
            const type_type& type)
  : ::xml_schema::type (),
    position_ (position, ::xml_schema::flags (), this),
    velocity_ (velocity, ::xml_schema::flags (), this),
    dimensions_ (dimensions, ::xml_schema::flags (), this),
    mass_ (mass, ::xml_schema::flags (), this),
    distance_ (distance, ::xml_schema::flags (), this),
    sigma_ (sigma, ::xml_schema::flags (), this),
    epsilon_ (epsilon, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    membrane_ (::xml_schema::flags (), this)
  {
  }

  cuboid_t::
  cuboid_t (const cuboid_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    position_ (x.position_, f, this),
    velocity_ (x.velocity_, f, this),
    dimensions_ (x.dimensions_, f, this),
    mass_ (x.mass_, f, this),
    distance_ (x.distance_, f, this),
    sigma_ (x.sigma_, f, this),
    epsilon_ (x.epsilon_, f, this),
    type_ (x.type_, f, this),
    membrane_ (x.membrane_, f, this)
  {
  }

  cuboid_t::
  cuboid_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    position_ (f, this),
    velocity_ (f, this),
    dimensions_ (f, this),
    mass_ (f, this),
    distance_ (f, this),
    sigma_ (f, this),
    epsilon_ (f, this),
    type_ (f, this),
    membrane_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void cuboid_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // position
      //
      if (n.name () == "position" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< position_type > r (
          position_traits::create (i, f, this));

        if (!position_.present ())
        {
          this->position_.set (r);
          continue;
        }
      }

      // velocity
      //
      if (n.name () == "velocity" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< velocity_type > r (
          velocity_traits::create (i, f, this));

        if (!velocity_.present ())
        {
          this->velocity_.set (r);
          continue;
        }
      }

      // dimensions
      //
      if (n.name () == "dimensions" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< dimensions_type > r (
          dimensions_traits::create (i, f, this));

        if (!dimensions_.present ())
        {
          this->dimensions_.set (r);
          continue;
        }
      }

      // mass
      //
      if (n.name () == "mass" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< mass_type > r (
          mass_traits::create (i, f, this));

        if (!mass_.present ())
        {
          this->mass_.set (r);
          continue;
        }
      }

      // distance
      //
      if (n.name () == "distance" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< distance_type > r (
          distance_traits::create (i, f, this));

        if (!distance_.present ())
        {
          this->distance_.set (r);
          continue;
        }
      }

      // sigma
      //
      if (n.name () == "sigma" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!sigma_.present ())
        {
          this->sigma_.set (sigma_traits::create (i, f, this));
          continue;
        }
      }

      // epsilon
      //
      if (n.name () == "epsilon" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!epsilon_.present ())
        {
          this->epsilon_.set (epsilon_traits::create (i, f, this));
          continue;
        }
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!type_.present ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }
      }

      // membrane
      //
      if (n.name () == "membrane" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< membrane_type > r (
          membrane_traits::create (i, f, this));

        if (!this->membrane_)
        {
          this->membrane_.set (r);
          continue;
        }
      }

      break;
    }

    if (!position_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "position",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!velocity_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "velocity",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!dimensions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dimensions",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mass",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!distance_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "distance",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!sigma_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "sigma",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!epsilon_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "epsilon",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  cuboid_t* cuboid_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class cuboid_t (*this, f, c);
  }

  cuboid_t::
  ~cuboid_t ()
  {
  }

  // sphere_t
  //

  sphere_t::
  sphere_t (const position_type& position,
            const velocity_type& velocity,
            const radiusDimension_type& radiusDimension,
            const mass_type& mass,
            const distance_type& distance,
            const sigma_type& sigma,
            const epsilon_type& epsilon,
            const type_type& type)
  : ::xml_schema::type (),
    position_ (position, ::xml_schema::flags (), this),
    velocity_ (velocity, ::xml_schema::flags (), this),
    radiusDimension_ (radiusDimension, ::xml_schema::flags (), this),
    mass_ (mass, ::xml_schema::flags (), this),
    distance_ (distance, ::xml_schema::flags (), this),
    sigma_ (sigma, ::xml_schema::flags (), this),
    epsilon_ (epsilon, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  sphere_t::
  sphere_t (::std::auto_ptr< position_type >& position,
            ::std::auto_ptr< velocity_type >& velocity,
            const radiusDimension_type& radiusDimension,
            const mass_type& mass,
            const distance_type& distance,
            const sigma_type& sigma,
            const epsilon_type& epsilon,
            const type_type& type)
  : ::xml_schema::type (),
    position_ (position, ::xml_schema::flags (), this),
    velocity_ (velocity, ::xml_schema::flags (), this),
    radiusDimension_ (radiusDimension, ::xml_schema::flags (), this),
    mass_ (mass, ::xml_schema::flags (), this),
    distance_ (distance, ::xml_schema::flags (), this),
    sigma_ (sigma, ::xml_schema::flags (), this),
    epsilon_ (epsilon, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  sphere_t::
  sphere_t (const sphere_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    position_ (x.position_, f, this),
    velocity_ (x.velocity_, f, this),
    radiusDimension_ (x.radiusDimension_, f, this),
    mass_ (x.mass_, f, this),
    distance_ (x.distance_, f, this),
    sigma_ (x.sigma_, f, this),
    epsilon_ (x.epsilon_, f, this),
    type_ (x.type_, f, this)
  {
  }

  sphere_t::
  sphere_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    position_ (f, this),
    velocity_ (f, this),
    radiusDimension_ (f, this),
    mass_ (f, this),
    distance_ (f, this),
    sigma_ (f, this),
    epsilon_ (f, this),
    type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void sphere_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // position
      //
      if (n.name () == "position" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< position_type > r (
          position_traits::create (i, f, this));

        if (!position_.present ())
        {
          this->position_.set (r);
          continue;
        }
      }

      // velocity
      //
      if (n.name () == "velocity" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< velocity_type > r (
          velocity_traits::create (i, f, this));

        if (!velocity_.present ())
        {
          this->velocity_.set (r);
          continue;
        }
      }

      // radiusDimension
      //
      if (n.name () == "radiusDimension" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!radiusDimension_.present ())
        {
          this->radiusDimension_.set (radiusDimension_traits::create (i, f, this));
          continue;
        }
      }

      // mass
      //
      if (n.name () == "mass" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< mass_type > r (
          mass_traits::create (i, f, this));

        if (!mass_.present ())
        {
          this->mass_.set (r);
          continue;
        }
      }

      // distance
      //
      if (n.name () == "distance" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< distance_type > r (
          distance_traits::create (i, f, this));

        if (!distance_.present ())
        {
          this->distance_.set (r);
          continue;
        }
      }

      // sigma
      //
      if (n.name () == "sigma" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!sigma_.present ())
        {
          this->sigma_.set (sigma_traits::create (i, f, this));
          continue;
        }
      }

      // epsilon
      //
      if (n.name () == "epsilon" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!epsilon_.present ())
        {
          this->epsilon_.set (epsilon_traits::create (i, f, this));
          continue;
        }
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!type_.present ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!position_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "position",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!velocity_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "velocity",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!radiusDimension_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "radiusDimension",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!mass_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mass",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!distance_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "distance",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!sigma_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "sigma",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!epsilon_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "epsilon",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  sphere_t* sphere_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sphere_t (*this, f, c);
  }

  sphere_t::
  ~sphere_t ()
  {
  }

  // inputs_t
  //

  inputs_t::
  inputs_t ()
  : ::xml_schema::type (),
    inputFile_ (::xml_schema::flags (), this),
    cuboid_ (::xml_schema::flags (), this),
    sphere_ (::xml_schema::flags (), this)
  {
  }

  inputs_t::
  inputs_t (const inputs_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    inputFile_ (x.inputFile_, f, this),
    cuboid_ (x.cuboid_, f, this),
    sphere_ (x.sphere_, f, this)
  {
  }

  inputs_t::
  inputs_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    inputFile_ (f, this),
    cuboid_ (f, this),
    sphere_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void inputs_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inputFile
      //
      if (n.name () == "inputFile" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< inputFile_type > r (
          inputFile_traits::create (i, f, this));

        this->inputFile_.push_back (r);
        continue;
      }

      // cuboid
      //
      if (n.name () == "cuboid" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< cuboid_type > r (
          cuboid_traits::create (i, f, this));

        this->cuboid_.push_back (r);
        continue;
      }

      // sphere
      //
      if (n.name () == "sphere" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< sphere_type > r (
          sphere_traits::create (i, f, this));

        this->sphere_.push_back (r);
        continue;
      }

      break;
    }
  }

  inputs_t* inputs_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class inputs_t (*this, f, c);
  }

  inputs_t::
  ~inputs_t ()
  {
  }

  // smoothedLennardJones_t
  //

  smoothedLennardJones_t::
  smoothedLennardJones_t (const rl_type& rl)
  : ::xml_schema::type (),
    rl_ (rl, ::xml_schema::flags (), this)
  {
  }

  smoothedLennardJones_t::
  smoothedLennardJones_t (const smoothedLennardJones_t& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    rl_ (x.rl_, f, this)
  {
  }

  smoothedLennardJones_t::
  smoothedLennardJones_t (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    rl_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void smoothedLennardJones_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // rl
      //
      if (n.name () == "rl" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< rl_type > r (
          rl_traits::create (i, f, this));

        if (!rl_.present ())
        {
          this->rl_.set (r);
          continue;
        }
      }

      break;
    }

    if (!rl_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "rl",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  smoothedLennardJones_t* smoothedLennardJones_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class smoothedLennardJones_t (*this, f, c);
  }

  smoothedLennardJones_t::
  ~smoothedLennardJones_t ()
  {
  }

  // potential_t
  //

  potential_t::
  potential_t ()
  : ::xml_schema::type (),
    gravitational_ (::xml_schema::flags (), this),
    lennardJones_ (::xml_schema::flags (), this),
    smoothedLennardJones_ (::xml_schema::flags (), this)
  {
  }

  potential_t::
  potential_t (const potential_t& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    gravitational_ (x.gravitational_, f, this),
    lennardJones_ (x.lennardJones_, f, this),
    smoothedLennardJones_ (x.smoothedLennardJones_, f, this)
  {
  }

  potential_t::
  potential_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    gravitational_ (f, this),
    lennardJones_ (f, this),
    smoothedLennardJones_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void potential_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // gravitational
      //
      if (n.name () == "gravitational" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< gravitational_type > r (
          gravitational_traits::create (i, f, this));

        if (!this->gravitational_)
        {
          this->gravitational_.set (r);
          continue;
        }
      }

      // lennardJones
      //
      if (n.name () == "lennardJones" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< lennardJones_type > r (
          lennardJones_traits::create (i, f, this));

        if (!this->lennardJones_)
        {
          this->lennardJones_.set (r);
          continue;
        }
      }

      // smoothedLennardJones
      //
      if (n.name () == "smoothedLennardJones" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< smoothedLennardJones_type > r (
          smoothedLennardJones_traits::create (i, f, this));

        if (!this->smoothedLennardJones_)
        {
          this->smoothedLennardJones_.set (r);
          continue;
        }
      }

      break;
    }
  }

  potential_t* potential_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class potential_t (*this, f, c);
  }

  potential_t::
  ~potential_t ()
  {
  }

  // boundary_t
  //

  boundary_t::
  boundary_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_boundary_t_convert ();
  }

  boundary_t::
  boundary_t (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_boundary_t_convert ();
  }

  boundary_t::
  boundary_t (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_boundary_t_convert ();
  }

  boundary_t* boundary_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundary_t (*this, f, c);
  }

  boundary_t::value boundary_t::
  _xsd_boundary_t_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_boundary_t_literals_);
    const value* i (::std::lower_bound (
                      _xsd_boundary_t_indexes_,
                      _xsd_boundary_t_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_boundary_t_indexes_ + 3 || _xsd_boundary_t_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const boundary_t::
  _xsd_boundary_t_literals_[3] =
  {
    "outflow",
    "reflecting",
    "periodic"
  };

  const boundary_t::value boundary_t::
  _xsd_boundary_t_indexes_[3] =
  {
    ::PSE_Molekulardynamik_WS12::boundary_t::outflow,
    ::PSE_Molekulardynamik_WS12::boundary_t::periodic,
    ::PSE_Molekulardynamik_WS12::boundary_t::reflecting
  };

  // domain_t
  //

  domain_t::
  domain_t (const dimensions_type& dimensions,
            const cutoff_type& cutoff,
            const x_type& x)
  : ::xml_schema::type (),
    dimensions_ (dimensions, ::xml_schema::flags (), this),
    cutoff_ (cutoff, ::xml_schema::flags (), this),
    x_ (x, ::xml_schema::flags (), this),
    y_ (::xml_schema::flags (), this),
    z_ (::xml_schema::flags (), this)
  {
  }

  domain_t::
  domain_t (::std::auto_ptr< dimensions_type >& dimensions,
            const cutoff_type& cutoff,
            ::std::auto_ptr< x_type >& x)
  : ::xml_schema::type (),
    dimensions_ (dimensions, ::xml_schema::flags (), this),
    cutoff_ (cutoff, ::xml_schema::flags (), this),
    x_ (x, ::xml_schema::flags (), this),
    y_ (::xml_schema::flags (), this),
    z_ (::xml_schema::flags (), this)
  {
  }

  domain_t::
  domain_t (const domain_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dimensions_ (x.dimensions_, f, this),
    cutoff_ (x.cutoff_, f, this),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  domain_t::
  domain_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dimensions_ (f, this),
    cutoff_ (f, this),
    x_ (f, this),
    y_ (f, this),
    z_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void domain_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dimensions
      //
      if (n.name () == "dimensions" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< dimensions_type > r (
          dimensions_traits::create (i, f, this));

        if (!dimensions_.present ())
        {
          this->dimensions_.set (r);
          continue;
        }
      }

      // cutoff
      //
      if (n.name () == "cutoff" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< cutoff_type > r (
          cutoff_traits::create (i, f, this));

        if (!cutoff_.present ())
        {
          this->cutoff_.set (r);
          continue;
        }
      }

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< y_type > r (
          y_traits::create (i, f, this));

        if (!this->y_)
        {
          this->y_.set (r);
          continue;
        }
      }

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< z_type > r (
          z_traits::create (i, f, this));

        if (!this->z_)
        {
          this->z_.set (r);
          continue;
        }
      }

      break;
    }

    if (!dimensions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dimensions",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!cutoff_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "cutoff",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  domain_t* domain_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class domain_t (*this, f, c);
  }

  domain_t::
  ~domain_t ()
  {
  }

  // thermostat_t
  //

  thermostat_t::
  thermostat_t (const initialT_type& initialT)
  : ::xml_schema::type (),
    initialT_ (initialT, ::xml_schema::flags (), this),
    frequency_ (::xml_schema::flags (), this)
  {
  }

  thermostat_t::
  thermostat_t (const thermostat_t& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    initialT_ (x.initialT_, f, this),
    frequency_ (x.frequency_, f, this)
  {
  }

  thermostat_t::
  thermostat_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    initialT_ (f, this),
    frequency_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void thermostat_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // initialT
      //
      if (n.name () == "initialT" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< initialT_type > r (
          initialT_traits::create (i, f, this));

        if (!initialT_.present ())
        {
          this->initialT_.set (r);
          continue;
        }
      }

      // frequency
      //
      if (n.name () == "frequency" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        if (!this->frequency_)
        {
          this->frequency_.set (frequency_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!initialT_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "initialT",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  thermostat_t* thermostat_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class thermostat_t (*this, f, c);
  }

  thermostat_t::
  ~thermostat_t ()
  {
  }

  // simulation_t
  //

  simulation_t::
  simulation_t (const inputs_type& inputs,
                const t_end_type& t_end,
                const delta_t_type& delta_t,
                const potential_type& potential,
                const dimensionCount_type& dimensionCount)
  : ::xml_schema::type (),
    output_ (::xml_schema::flags (), this),
    outputPhaseSpace_ (::xml_schema::flags (), this),
    inputs_ (inputs, ::xml_schema::flags (), this),
    t_end_ (t_end, ::xml_schema::flags (), this),
    delta_t_ (delta_t, ::xml_schema::flags (), this),
    potential_ (potential, ::xml_schema::flags (), this),
    domain_ (::xml_schema::flags (), this),
    thermostat_ (::xml_schema::flags (), this),
    dimensionCount_ (dimensionCount, ::xml_schema::flags (), this),
    gravitation_ (::xml_schema::flags (), this)
  {
  }

  simulation_t::
  simulation_t (::std::auto_ptr< inputs_type >& inputs,
                const t_end_type& t_end,
                const delta_t_type& delta_t,
                ::std::auto_ptr< potential_type >& potential,
                const dimensionCount_type& dimensionCount)
  : ::xml_schema::type (),
    output_ (::xml_schema::flags (), this),
    outputPhaseSpace_ (::xml_schema::flags (), this),
    inputs_ (inputs, ::xml_schema::flags (), this),
    t_end_ (t_end, ::xml_schema::flags (), this),
    delta_t_ (delta_t, ::xml_schema::flags (), this),
    potential_ (potential, ::xml_schema::flags (), this),
    domain_ (::xml_schema::flags (), this),
    thermostat_ (::xml_schema::flags (), this),
    dimensionCount_ (dimensionCount, ::xml_schema::flags (), this),
    gravitation_ (::xml_schema::flags (), this)
  {
  }

  simulation_t::
  simulation_t (const simulation_t& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    output_ (x.output_, f, this),
    outputPhaseSpace_ (x.outputPhaseSpace_, f, this),
    inputs_ (x.inputs_, f, this),
    t_end_ (x.t_end_, f, this),
    delta_t_ (x.delta_t_, f, this),
    potential_ (x.potential_, f, this),
    domain_ (x.domain_, f, this),
    thermostat_ (x.thermostat_, f, this),
    dimensionCount_ (x.dimensionCount_, f, this),
    gravitation_ (x.gravitation_, f, this)
  {
  }

  simulation_t::
  simulation_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    output_ (f, this),
    outputPhaseSpace_ (f, this),
    inputs_ (f, this),
    t_end_ (f, this),
    delta_t_ (f, this),
    potential_ (f, this),
    domain_ (f, this),
    thermostat_ (f, this),
    dimensionCount_ (f, this),
    gravitation_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void simulation_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< output_type > r (
          output_traits::create (i, f, this));

        if (!this->output_)
        {
          this->output_.set (r);
          continue;
        }
      }

      // outputPhaseSpace
      //
      if (n.name () == "outputPhaseSpace" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< outputPhaseSpace_type > r (
          outputPhaseSpace_traits::create (i, f, this));

        if (!this->outputPhaseSpace_)
        {
          this->outputPhaseSpace_.set (r);
          continue;
        }
      }

      // inputs
      //
      if (n.name () == "inputs" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< inputs_type > r (
          inputs_traits::create (i, f, this));

        if (!inputs_.present ())
        {
          this->inputs_.set (r);
          continue;
        }
      }

      // t_end
      //
      if (n.name () == "t_end" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< t_end_type > r (
          t_end_traits::create (i, f, this));

        if (!t_end_.present ())
        {
          this->t_end_.set (r);
          continue;
        }
      }

      // delta_t
      //
      if (n.name () == "delta_t" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< delta_t_type > r (
          delta_t_traits::create (i, f, this));

        if (!delta_t_.present ())
        {
          this->delta_t_.set (r);
          continue;
        }
      }

      // potential
      //
      if (n.name () == "potential" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< potential_type > r (
          potential_traits::create (i, f, this));

        if (!potential_.present ())
        {
          this->potential_.set (r);
          continue;
        }
      }

      // domain
      //
      if (n.name () == "domain" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< domain_type > r (
          domain_traits::create (i, f, this));

        if (!this->domain_)
        {
          this->domain_.set (r);
          continue;
        }
      }

      // thermostat
      //
      if (n.name () == "thermostat" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< thermostat_type > r (
          thermostat_traits::create (i, f, this));

        if (!this->thermostat_)
        {
          this->thermostat_.set (r);
          continue;
        }
      }

      // dimensionCount
      //
      if (n.name () == "dimensionCount" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< dimensionCount_type > r (
          dimensionCount_traits::create (i, f, this));

        if (!dimensionCount_.present ())
        {
          this->dimensionCount_.set (r);
          continue;
        }
      }

      // gravitation
      //
      if (n.name () == "gravitation" && n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
      {
        ::std::auto_ptr< gravitation_type > r (
          gravitation_traits::create (i, f, this));

        if (!this->gravitation_)
        {
          this->gravitation_.set (r);
          continue;
        }
      }

      break;
    }

    if (!inputs_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "inputs",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!t_end_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "t_end",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!delta_t_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "delta_t",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!potential_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "potential",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }

    if (!dimensionCount_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dimensionCount",
        "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
    }
  }

  simulation_t* simulation_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class simulation_t (*this, f, c);
  }

  simulation_t::
  ~simulation_t ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace PSE_Molekulardynamik_WS12
{
  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t > r (
      ::PSE_Molekulardynamik_WS12::simulation (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t > r (
      ::PSE_Molekulardynamik_WS12::simulation (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t > r (
      ::PSE_Molekulardynamik_WS12::simulation (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::PSE_Molekulardynamik_WS12::simulation (isrc, f, p);
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::PSE_Molekulardynamik_WS12::simulation (isrc, h, f, p);
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::PSE_Molekulardynamik_WS12::simulation (isrc, h, f, p);
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::PSE_Molekulardynamik_WS12::simulation (isrc, f, p);
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::PSE_Molekulardynamik_WS12::simulation (isrc, h, f, p);
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::PSE_Molekulardynamik_WS12::simulation (isrc, h, f, p);
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t > r (
      ::PSE_Molekulardynamik_WS12::simulation (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t > r (
      ::PSE_Molekulardynamik_WS12::simulation (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t > r (
      ::PSE_Molekulardynamik_WS12::simulation (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t > r (
        ::PSE_Molekulardynamik_WS12::simulation (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "simulation" &&
        n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
    {
      ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t > r (
        ::xsd::cxx::tree::traits< ::PSE_Molekulardynamik_WS12::simulation_t, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "simulation",
      "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
  }

  ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t >
  simulation (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "simulation" &&
        n.namespace_ () == "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12")
    {
      ::std::auto_ptr< ::PSE_Molekulardynamik_WS12::simulation_t > r (
        ::xsd::cxx::tree::traits< ::PSE_Molekulardynamik_WS12::simulation_t, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "simulation",
      "http://www5.in.tum.de/wiki/index.php/PSE_Molekulardynamik_WS12");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

